<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>React 基本結構解析和入坑建議 | Arsfy' Blog</title><meta name=keywords content="React,Frontend"><meta name=description content="本文寫給入坑 React 時間不長，或想要入坑的新人，但是本文不會介紹為甚麼選擇 React 和 React 的優點 1. 為甚麼應該學習原生前端三大件 HTML, Javascript, CSS 是整個前端程式的組成，在"><meta name=author content="Arsfy"><link rel=canonical href=https://arsfy.top/post/react-code-structure/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://arsfy.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://arsfy.top/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://arsfy.top/favicon16x16.png><link rel=apple-touch-icon href=https://arsfy.top/apple-touch-icon.png><link rel=mask-icon href=https://arsfy.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="React 基本結構解析和入坑建議"><meta property="og:description" content="本文寫給入坑 React 時間不長，或想要入坑的新人，但是本文不會介紹為甚麼選擇 React 和 React 的優點 1. 為甚麼應該學習原生前端三大件 HTML, Javascript, CSS 是整個前端程式的組成，在"><meta property="og:type" content="article"><meta property="og:url" content="https://arsfy.top/post/react-code-structure/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-09-02T05:12:25+08:00"><meta property="article:modified_time" content="2023-09-02T05:12:25+08:00"><meta property="og:site_name" content="Arsfy's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="React 基本結構解析和入坑建議"><meta name=twitter:description content="本文寫給入坑 React 時間不長，或想要入坑的新人，但是本文不會介紹為甚麼選擇 React 和 React 的優點 1. 為甚麼應該學習原生前端三大件 HTML, Javascript, CSS 是整個前端程式的組成，在"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://arsfy.top/post/"},{"@type":"ListItem","position":2,"name":"React 基本結構解析和入坑建議","item":"https://arsfy.top/post/react-code-structure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"React 基本結構解析和入坑建議","name":"React 基本結構解析和入坑建議","description":"本文寫給入坑 React 時間不長，或想要入坑的新人，但是本文不會介紹為甚麼選擇 React 和 React 的優點 1. 為甚麼應該學習原生前端三大件 HTML, Javascript, CSS 是整個前端程式的組成，在","keywords":["React","Frontend"],"articleBody":"本文寫給入坑 React 時間不長，或想要入坑的新人，但是本文不會介紹為甚麼選擇 React 和 React 的優點\n1. 為甚麼應該學習原生前端三大件 HTML, Javascript, CSS 是整個前端程式的組成，在不使用任何開發框架的情況下，你可以分別手動編寫這三個語言以實現不同的功能。\n它們是 Web 前端的組成部分，使用現代前端框架並不意味着跳過他們，而是使用 JS 生成對應的 HTML Code，填充對應的樣式。\nReact 幫你做好了這一步，所以你應該瞭解到 React 做的工作，理解這一步的過程而不是直接跳過。有足夠的基礎對未來的開發會有好大幫助，學習匯編開發可以幫到你瞭解應用程式的本質，CPU指令集的作用，但是匯編工作量好大並無實際用途，三大件足夠簡單，學習性價比值得推介。\n2. React 是如何渲染頁面的 如果你有創建過 React project 的話，你應該有發現除 public/index.html 之外並沒有其他的 HTML，唯一的 HTML 檔案內也沒有任何可見內容。因為 React 是一個 JS 框架，它是使用 Javascript 在瀏覽器中創建所有組件，它的渲染方式和傳統的透過 path 在伺服器中獲取指定檔案完全不同。\nReact 使用虛擬 DOM 渲染，虛擬 DOM 是 React 自己維護的一個內存中的樹形結構，它將整個 DOM 樹的狀態以 JavaScript 物件的形式保存在內存中。每個 React 元件都對應著虛擬 DOM 中的一個節點。在應用狀態（詳見下文 state）發生變化時，React 首先會計算出新的虛擬 DOM，然後將新的虛擬 DOM 和舊的虛擬 DOM 進行比較，找出差異之處，React 只會將真正有變化的部分更新到實際的 DOM 上，而不是重新渲染整個應用的 DOM 樹。\n相比之下，直接操作實際 DOM 會比較慢，因為實際 DOM 的操作會觸發瀏覽器的重排和重繪操作，這些操作對於性能來說是比較昂貴的。而 React 的虛擬 DOM 操作都是在內存中進行的，不會觸發瀏覽器的重排和重繪，因此性能更優。\n2.1. 純粹的虛擬 DOM 虛擬 DOM 意味着在首次打開 React 網站之後，接下來的所有樣式和顯示內容都將由 JS 控制，就算是切換頁面也只是 JS 更換顯示內容。\n這個示例中使用一個內嵌在 JSX 中的判斷決定是否輸出 Hid\n這個元素，show 為 false 所以 Hid\n不會被包含在這個 div 內，JS 就完全不會在 HTML 中輸出這個元素，和 CSS display: none; 隱藏不同。\nconst show = false; return (\u003cdiv\u003e {show \u0026\u0026 \u003cp\u003eHid\u003c/p\u003e} \u003c/div\u003e) 2.2. state 更新 在 React 中，state 是一個重要的概念，它代表了組件的內部狀態。當 state 更新時，React 會重新渲染該組件，反映出新的狀態。\n例如，我們可以創建一個有狀態的組件，該組件有一個按鈕，每次點擊按鈕都會更新 state，並導致組件重新渲染。\nclass MyComponent extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } handleClick = () =\u003e { this.setState({ count: this.state.count + 1 }); } render() { return ( \u003cdiv\u003e \u003cp\u003eYou clicked {this.state.count} times\u003c/p\u003e \u003cbutton onClick={this.handleClick}\u003e Click me \u003c/button\u003e \u003c/div\u003e ); } } 在這個例子中，每次點擊按鈕，handleClick 方法就會被調用，並更新 state。React 會檢測到 state 的變化，並重新渲染組件，更新顯示的點擊次數。\n3. React 的基本結構 React 的基本結構由組件（Components）構成。每個組件都有自己的狀態（state）和生命週期（lifecycle）。組件可以包含其他組件，形成一個組件樹，這就是 React 應用的結構。\n組件可以是函數組件或者類組件。函數組件是一種簡單的組件形式，只包含一個渲染函數。類組件更複雜，可以包含狀態和生命週期方法。\n函數組件：\nfunction Welcome(props) { return \u003ch1\u003eHello, {props.name}\u003c/h1\u003e; } 類組件：\nclass Welcome extends React.Component { render() { return \u003ch1\u003eHello, {this.props.name}\u003c/h1\u003e; } } 調用:\n\u003cWelcome name=\"World\" /\u003e 在這兩個例子中，我們都定義了一個名為 Welcome 的組件，它接收一個 props 參數，並在渲染時將其顯示出來。函數組件和類組件在使用上有些不同，但他們的主要目的都是定義如何渲染組件。\n雖然 React 官方更喜歡使用函數組件的方式，推薦文章： 《为什么react选择了函数式组件（剖析原理）》\n4. 如何使用 React 創建多頁面，無重載網頁 在傳統的網頁開發中，每個頁面都對應一個 HTML 文件。但在 React 中，我們可以使用路由（Routing）來實現多頁面應用。這種方式下，所有的頁面都在同一個 HTML 文件中，並由 JavaScript 控制哪個組件（頁面）被渲染。\n推薦使用 React Router 庫，但是 React Router 版本疊代較快，請詳見官方網站上面的例子。\n5. 在入坑 React 時可能遇到的問題 理解 state 和 props：state 和 props 是 React 中兩個重要的概念。state 是組件的內部狀態，props 是從父組件傳遞給子組件的數據。詳見：State and Lifecycle\n理解組件生命週期：每個 React 組件都有一個生命週期，它包括掛載（mounting）、更新（updating）和卸載（unmounting）三個階段。每個階段都有相應的生命週期方法。同樣詳見：State and Lifecycle\n理解列表和鍵: 我們可以在 render 中使用 map 函數來渲染列表。每個列表項目都需要一個唯一的 key 屬性。詳見: Lists and Keys\n理解表單處理：表單處理和傳統的 HTML 表單處理有些不同。React 推薦使用受控組件來處理表單輸入。詳見：Forms\n想到了再加\n6. WHY NOT VUE 我喜歡 XD\n也可能因為我是 Backend 出身\n","wordCount":"1825","inLanguage":"en","datePublished":"2023-09-02T05:12:25+08:00","dateModified":"2023-09-02T05:12:25+08:00","author":{"@type":"Person","name":"Arsfy"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://arsfy.top/post/react-code-structure/"},"publisher":{"@type":"Organization","name":"Arsfy' Blog","logo":{"@type":"ImageObject","url":"https://arsfy.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://arsfy.top/ accesskey=h title="Arsfy' Blog (Alt + H)">Arsfy' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://arsfy.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://arsfy.top/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://arsfy.top/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://arsfy.top/>Home</a>&nbsp;»&nbsp;<a href=https://arsfy.top/post/>Posts</a></div><h1 class=post-title>React 基本結構解析和入坑建議</h1><div class=post-meta><span title='2023-09-02 05:12:25 +0800 CST'>September 2, 2023</span>&nbsp;·&nbsp;1825 words&nbsp;·&nbsp;Arsfy</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-為甚麼應該學習原生前端三大件>1. 為甚麼應該學習原生前端三大件</a></li><li><a href=#2-react-是如何渲染頁面的>2. React 是如何渲染頁面的</a><ul><li><a href=#21-純粹的虛擬-dom>2.1. 純粹的虛擬 DOM</a></li><li><a href=#22-state-更新>2.2. <code>state</code> 更新</a></li></ul></li><li><a href=#3-react-的基本結構>3. React 的基本結構</a></li><li><a href=#4-如何使用-react-創建多頁面無重載網頁>4. 如何使用 React 創建多頁面，無重載網頁</a></li><li><a href=#5-在入坑-react-時可能遇到的問題>5. 在入坑 React 時可能遇到的問題</a></li><li><a href=#6-why-not-vue>6. WHY NOT VUE</a></li></ul></nav></div></details></div><div class=post-content><p>本文寫給入坑 React 時間不長，或想要入坑的新人，但是本文不會介紹為甚麼選擇 React 和 React 的優點</p><h2 id=1-為甚麼應該學習原生前端三大件>1. 為甚麼應該學習原生前端三大件<a hidden class=anchor aria-hidden=true href=#1-為甚麼應該學習原生前端三大件>#</a></h2><p><code>HTML</code>, <code>Javascript</code>, <code>CSS</code> 是整個前端程式的組成，在不使用任何開發框架的情況下，你可以分別手動編寫這三個語言以實現不同的功能。</p><p>它們是 Web 前端的組成部分，使用現代前端框架並不意味着跳過他們，而是使用 JS 生成對應的 HTML Code，填充對應的樣式。</p><p>React 幫你做好了這一步，所以你應該瞭解到 React 做的工作，理解這一步的過程而不是直接跳過。有足夠的基礎對未來的開發會有好大幫助，學習匯編開發可以幫到你瞭解應用程式的本質，CPU指令集的作用，但是匯編工作量好大並無實際用途，三大件足夠簡單，學習性價比值得推介。</p><h2 id=2-react-是如何渲染頁面的>2. React 是如何渲染頁面的<a hidden class=anchor aria-hidden=true href=#2-react-是如何渲染頁面的>#</a></h2><p>如果你有創建過 React project 的話，你應該有發現除 <code>public/index.html</code> 之外並沒有其他的 HTML，唯一的 HTML 檔案內也沒有任何可見內容。因為 React 是一個 JS 框架，它是使用 Javascript 在瀏覽器中創建所有組件，它的渲染方式和傳統的透過 path 在伺服器中獲取指定檔案完全不同。</p><p>React 使用虛擬 DOM 渲染，虛擬 DOM 是 React 自己維護的一個內存中的樹形結構，它將整個 DOM 樹的狀態以 JavaScript 物件的形式保存在內存中。每個 React 元件都對應著虛擬 DOM 中的一個節點。在應用狀態（詳見下文 <code>state</code>）發生變化時，React 首先會計算出新的虛擬 DOM，然後將新的虛擬 DOM 和舊的虛擬 DOM 進行比較，找出差異之處，React 只會將真正有變化的部分更新到實際的 DOM 上，而不是重新渲染整個應用的 DOM 樹。</p><p>相比之下，直接操作實際 DOM 會比較慢，因為實際 DOM 的操作會觸發瀏覽器的重排和重繪操作，這些操作對於性能來說是比較昂貴的。而 React 的虛擬 DOM 操作都是在內存中進行的，不會觸發瀏覽器的重排和重繪，因此性能更優。</p><h3 id=21-純粹的虛擬-dom>2.1. 純粹的虛擬 DOM<a hidden class=anchor aria-hidden=true href=#21-純粹的虛擬-dom>#</a></h3><p>虛擬 DOM 意味着在首次打開 React 網站之後，接下來的所有樣式和顯示內容都將由 JS 控制，就算是切換頁面也只是 JS 更換顯示內容。</p><p>這個示例中使用一個內嵌在 JSX 中的判斷決定是否輸出 <code>&lt;p>Hid&lt;/p></code> 這個元素，<code>show</code> 為 <code>false</code> 所以 <code>&lt;p>Hid&lt;/p></code> 不會被包含在這個 <code>div</code> 內，JS 就完全不會在 HTML 中輸出這個元素，和 CSS <code>display: none;</code> 隱藏不同。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kr>const</span> <span class=nx>show</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=p>(&lt;</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nx>show</span> <span class=o>&amp;&amp;</span> <span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;</span><span class=nx>Hid</span><span class=p>&lt;/</span><span class=nt>p</span><span class=p>&gt;}</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;)</span>
</span></span></code></pre></div><h3 id=22-state-更新>2.2. <code>state</code> 更新<a hidden class=anchor aria-hidden=true href=#22-state-更新>#</a></h3><p>在 React 中，state 是一個重要的概念，它代表了組件的內部狀態。當 state 更新時，React 會重新渲染該組件，反映出新的狀態。</p><p>例如，我們可以創建一個有狀態的組件，該組件有一個按鈕，每次點擊按鈕都會更新 state，並導致組件重新渲染。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kr>class</span> <span class=nx>MyComponent</span> <span class=kr>extends</span> <span class=nx>React</span><span class=p>.</span><span class=nx>Component</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>constructor</span><span class=p>(</span><span class=nx>props</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>super</span><span class=p>(</span><span class=nx>props</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>state</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>count</span><span class=o>:</span> <span class=mi>0</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>handleClick</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>setState</span><span class=p>({</span> <span class=nx>count</span><span class=o>:</span> <span class=k>this</span><span class=p>.</span><span class=nx>state</span><span class=p>.</span><span class=nx>count</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>render</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>                <span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;</span><span class=nx>You</span> <span class=nx>clicked</span> <span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>state</span><span class=p>.</span><span class=nx>count</span><span class=p>}</span> <span class=nx>times</span><span class=p>&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>                <span class=p>&lt;</span><span class=nt>button</span> <span class=na>onClick</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>handleClick</span><span class=p>}&gt;</span>
</span></span><span class=line><span class=cl>                    <span class=nx>Click</span> <span class=nx>me</span>
</span></span><span class=line><span class=cl>                <span class=p>&lt;/</span><span class=nt>button</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>            <span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在這個例子中，每次點擊按鈕，<code>handleClick</code> 方法就會被調用，並更新 <code>state</code>。React 會檢測到 <code>state</code> 的變化，並重新渲染組件，更新顯示的點擊次數。</p><h2 id=3-react-的基本結構>3. React 的基本結構<a hidden class=anchor aria-hidden=true href=#3-react-的基本結構>#</a></h2><p>React 的基本結構由組件（Components）構成。每個組件都有自己的狀態（state）和生命週期（lifecycle）。組件可以包含其他組件，形成一個組件樹，這就是 React 應用的結構。</p><p>組件可以是函數組件或者類組件。函數組件是一種簡單的組件形式，只包含一個渲染函數。類組件更複雜，可以包含狀態和生命週期方法。</p><p>函數組件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kd>function</span> <span class=nx>Welcome</span><span class=p>(</span><span class=nx>props</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>&lt;</span><span class=nt>h1</span><span class=p>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=p>{</span><span class=nx>props</span><span class=p>.</span><span class=nx>name</span><span class=p>}&lt;/</span><span class=nt>h1</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>類組件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kr>class</span> <span class=nx>Welcome</span> <span class=kr>extends</span> <span class=nx>React</span><span class=p>.</span><span class=nx>Component</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>render</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>&lt;</span><span class=nt>h1</span><span class=p>&gt;</span><span class=nx>Hello</span><span class=p>,</span> <span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>name</span><span class=p>}&lt;/</span><span class=nt>h1</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>調用:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>Welcome</span> <span class=na>name</span><span class=o>=</span><span class=s>&#34;World&#34;</span> <span class=p>/&gt;</span>
</span></span></code></pre></div><p>在這兩個例子中，我們都定義了一個名為 <code>Welcome</code> 的組件，它接收一個 <code>props</code> 參數，並在渲染時將其顯示出來。函數組件和類組件在使用上有些不同，但他們的主要目的都是定義如何渲染組件。</p><p>雖然 React 官方更喜歡使用函數組件的方式，推薦文章： 《<a href=https://zhuanlan.zhihu.com/p/511497733>为什么react选择了函数式组件（剖析原理）</a>》</p><h2 id=4-如何使用-react-創建多頁面無重載網頁>4. 如何使用 React 創建多頁面，無重載網頁<a hidden class=anchor aria-hidden=true href=#4-如何使用-react-創建多頁面無重載網頁>#</a></h2><p>在傳統的網頁開發中，每個頁面都對應一個 HTML 文件。但在 React 中，我們可以使用路由（Routing）來實現多頁面應用。這種方式下，所有的頁面都在同一個 HTML 文件中，並由 JavaScript 控制哪個組件（頁面）被渲染。</p><p>推薦使用 React Router 庫，但是 React Router 版本疊代較快，請詳見<a href=https://reactrouter.com>官方網站</a>上面的例子。</p><h2 id=5-在入坑-react-時可能遇到的問題>5. 在入坑 React 時可能遇到的問題<a hidden class=anchor aria-hidden=true href=#5-在入坑-react-時可能遇到的問題>#</a></h2><ol><li><p><strong>理解 state 和 props</strong>：state 和 props 是 React 中兩個重要的概念。state 是組件的內部狀態，props 是從父組件傳遞給子組件的數據。詳見：<a href=https://legacy.reactjs.org/docs/state-and-lifecycle.html>State and Lifecycle</a></p></li><li><p><strong>理解組件生命週期</strong>：每個 React 組件都有一個生命週期，它包括掛載（mounting）、更新（updating）和卸載（unmounting）三個階段。每個階段都有相應的生命週期方法。同樣詳見：<a href=https://reactjs.org/docs/state-and-lifecycle.html>State and Lifecycle</a></p></li><li><p><strong>理解列表和鍵</strong>: 我們可以在 <code>render</code> 中使用 <code>map</code> 函數來渲染列表。每個列表項目都需要一個唯一的 <code>key</code> 屬性。詳見: <a href=https://reactjs.org/docs/lists-and-keys.html>Lists and Keys</a></p></li><li><p><strong>理解表單處理</strong>：表單處理和傳統的 HTML 表單處理有些不同。React 推薦使用受控組件來處理表單輸入。詳見：<a href=https://reactjs.org/docs/forms.html>Forms</a></p></li><li><p><strong>想到了再加</strong></p></li></ol><h2 id=6-why-not-vue>6. WHY NOT VUE<a hidden class=anchor aria-hidden=true href=#6-why-not-vue>#</a></h2><p>我喜歡 XD</p><p>也可能因為我是 Backend 出身</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://arsfy.top/tags/react/>React</a></li><li><a href=https://arsfy.top/tags/frontend/>Frontend</a></li></ul><nav class=paginav><a class=prev href=https://arsfy.top/post/trie/><span class=title>« Prev</span><br><span>Golang：Trie 實現與數據結構設計</span></a>
<a class=next href=https://arsfy.top/post/pve-qm-2/><span class=title>Next »</span><br><span>PVE qm 命令 #2: 製作 VM Template</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://arsfy.top/>Arsfy' Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>