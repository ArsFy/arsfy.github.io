[{"content":"Trie，又稱前綴樹或字典樹，是一種用於快速查找和插入字串的數據結構。\n結構設計 Trie 是一種多路樹數據結構，每個字串都是由根節點到某個節點的路徑表示的，所以我們需要一個結構來表示節點，把它定義為 TrieNode。每個 TrieNode 都有一個子節點映射，將字符映射到 TrieNode，這樣我們就可以通過字符來查找子節點。每個節點還需要一個標記來表示該節點是否為一個完整的字串的結束，以及一個字段來存儲該節點的值。\ntype TrieNode struct { children map[rune]*TrieNode end bool value string } children 是一個映射，將 rune 映射到 TrieNode 指針，實現多子節點。end 是一個 Boolean 類型，表示是否是一個完整字串的結束。value 是一個 String 類型，表示該節點的值。\nrune 是 int32 的別名，[]rune 可以用於表示 Unicode 字符串，每個 rune 類型對應一個 Unicode 字符，這允許我們按字符（而不是字節）操作字符串，這對處理包含非 ASCII 字符非常重要，因為這些字符通常由多個字節表示，直接切片會產生亂碼。\n插入邏輯 首先將當前節點設置為根節點，遍歷輸入的字串的每個字符，如果被遍歷到的字符不存在於當前節點的子節點中，則創建一個新的 TrieNode 並將其添加到子節點映射中。然後我們將當前節點設定為子節點，並繼續處理下一個字符。直到處理完所有字符後將 end 設定為 true，表示這個節點為一個完整的字串的結束，並將 value 設置為傳入的 value，這在下面的 Search 中被用於輸出被替換的目標值。\nfunc (t *TrieNode) Insert(word, value string) { node := t for _, ch := range word { if node.children[ch] == nil { node.children[ch] = \u0026amp;TrieNode{children: make(map[rune]*TrieNode)} } node = node.children[ch] } node.end = true node.value = value } 查找邏輯 同樣將當前節點設置為根節點，遍歷輸入的字串的每個字符，如果被遍歷到的字符存在於當前節點的子節點中，則將當前節點設置為該子節點。否則，返回空字串和 0。如果找到一個結束節點，則返回該節點的值和搜索的長度。\n在下面的應用中，這個方法返回的值和長度被用於寫入 output 字串和跳過對應的長度。\nfunc (t *TrieNode) Search(s []rune) (string, int) { node := t for i, ch := range s { if node.children[ch] == nil { return \u0026#34;\u0026#34;, 0 } node = node.children[ch] if node.end { return node.value, i + 1 } } return \u0026#34;\u0026#34;, 0 } 應用: 查找並替換 func ConvertWords(input string, root *TrieNode) string { var output strings.Builder runes := []rune(input) i := 0 for i \u0026lt; len(runes) { word, length := root.Search(runes[i:]) if length \u0026gt; 0 { output.WriteString(word) i += length } else { output.WriteRune(runes[i]) i++ } } return output.String() } ConvertWords 方法實現了將傳入字串中的每個單詞轉換為 Trie 中對應的值。\n首先把傳入的字串 input 轉換為 []rune 類型並遍歷，調用 Search 查找從當前字符開始的最長單詞，並返回單詞和長度。如有匹配的單詞就寫入 output 並跳過這個單詞的長度，如果沒有找到單詞，就繼續處理下一個單詞。\n這個算法的時間複雜度為 O(n)，雖然每個字符都調用了 Search 方法，但是因為有跳過被找到的單詞長度，所以總時間複雜度仍然是 O(n)\nGithub Repo ArsFy/convertwords\nfunc main() { root := New() root.Insert(\u0026#34;蘋果\u0026#34;, \u0026#34;水果\u0026#34;) root.Insert(\u0026#34;香蕉\u0026#34;, \u0026#34;水果\u0026#34;) root.Insert(\u0026#34;蘿蔔\u0026#34;, \u0026#34;蔬菜\u0026#34;) input := \u0026#34;我喜歡蘋果和香蕉，但是不喜歡蘿蔔。\u0026#34; output := ConvertWords(input, root) println(output) // 我喜歡水果和水果，但是不喜歡蔬菜 } ","permalink":"https://arsfy.top/post/trie/","summary":"Trie，又稱前綴樹或字典樹，是一種用於快速查找和插入字串的數據結構。 結構設計 Trie 是一種多路樹數據結構，每個字串都是由根節點到某個節點的路徑表","title":"Golang：Trie 實現與數據結構設計"},{"content":"本文寫給入坑 React 時間還不長的新人，我將會在本文中講到：\n為什麽在學習 JS 現代前端框架前應該學習原生 HTML, JavaScript, CSS React 是如何渲染頁面的 React 的基本結構 如何使用 React 創建多頁面，無重載網頁 在入坑 React 時可能遇到的問題 以上是本文的概要，具體内容可以透過 Blog 頂部目錄跳轉（本文不會介紹爲什麽選擇 React 和 React 的優點）\n1. 為什麽應該學習原生前端三大件 HTML, Javascript, CSS 是整個前端程式的組成，在不使用任何開發框架的情況下，你可以分別手動編寫這三個語言以實現不同的功能。\n它們是 Web 前端的組成部分，使用現代前端框架并沒有跳過他們，而是使用 JS 生成對應的 HTML Code，填充對應的樣式。\n正是因為 React 幫你做好了這一步，所以你應該瞭解到 React 做的工作，理解這一步的過程而不是直接跳過。有足夠的基礎對未來的開發會有好大幫助，學習匯編開發可以幫到你瞭解應用程式的本質，CPU指令集的作用，但是匯編工作量好大並無實際用途，三大件足夠簡單，學習性價比值得推介。\n下一節會介紹 React 的工作。\n2. React 是如何渲染頁面的 如果你有創建過 React project 的話，你應該有發現除 public/index.html 之外并沒有其他的 HTML，唯一的 HTML 檔案内也沒有任何可見内容。因為 React 是一個 JS 框架，它是使用 Javascript 在瀏覽器中創建所有組件，它的渲染方式和傳統的透過 path 在伺服器中獲取指定檔案完全不同。\n2.1. 純粹的 JS 生成 純粹的 JS 生成意味著在首次打開 React 網站之後，接下來的所有樣式和顯示内容都將由 JS 控制，就算是切換頁面也只是 JS 更換顯示内容。\n下面的示例中使用一個内嵌在 JSX 中的判斷決定是否輸出 \u0026lt;p\u0026gt;Hid\u0026lt;/p\u0026gt; 這個元素，show 為 false 所以 \u0026lt;p\u0026gt;Hid\u0026lt;/p\u0026gt; 不會被包含在這個 div 内，JS 就完全不會在 HTML 中輸出這個元素，和 CSS display: none; 隱藏不同。\nconst show = false; return (\u0026lt;div\u0026gt; {show \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Hid\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt;) 2.2. state 更新 ","permalink":"https://arsfy.top/post/react-code-structure/","summary":"本文寫給入坑 React 時間還不長的新人，我將會在本文中講到： 為什麽在學習 JS 現代前端框架前應該學習原生 HTML, JavaScript, CSS React 是如何渲染頁面的 React 的基本結構 如何使用 React 創","title":"React 基本結構解析和入坑建議"},{"content":"PVE (Proxmox VE) 提供 VM Template 功能，把一台已經創建好的 VM 轉換為 Template，這在需求大量相同 VM 的場景非常有用。\n本節將會展示如何製作 VM Template，並配置 Cloud-init 等。\n瞭解必要内容 1. 為什麽需要 VM Template？ VM Template 可以幫到你快速創建即建即用的預設 VM，以模板形式無限克隆。\n2. 什麽是 cloud-init cloud-init 是一種在 VM 首次啓動時初始化自定義配置的程式，可以自動化設定 username, password, ip, sshKey 等。\n開始 1. 作業系統鏡像 示例將會使用 debian 11 作爲演示\ncloud-init 是一個應用程式，推薦使用包含 cloud-init 的系統鏡像進行安裝，各大發行版都會有提供 cloud 版本。\n打開下載頁面，下載自己需要的版本 / 架構。\n本次示例要下載的是 debian 11 的 AMD64 版本，記得下載 qcow2 格式或者 img 格式。\nhttps://cloud.debian.org/images/cloud/bullseye/20230802-1460/debian-11-generic-amd64-20230802-1460.qcow2 使用 wget 下載到當前目錄備用，並重命名為 debian-11-amd64.qcow2\nwget -O debian-11-amd64.qcow2 https://cloud.debian.org/images/cloud/bullseye/20230802-1460/debian-11-generic-amd64-20230802-1460.qcow2 2. 創建 VM 在成為 Template 之前，首先是一台可以正常使用的 VM，這裏使用 qm 命令創建 VM。\n2: CPU 核心數 8000: VM ID，請盡量使用足夠高的 ID 以防止和普通 VM 衝突 2048: 記憶體大小，單位 MB virtio,bridge=vmbr0: 虛擬 netcard，virtio 類型並橋接在 vmbr0 上面，請提前創建 Linux 橋 vmbr0 在這裏省略任何參數都將使用默認值，非必要裝置不會創建 qm create 8000 --cores 2 --memory 2048 --name debian-11 --net0 virtio,bridge=vmbr0 3. 導入虛擬 Disk 8000: 在第二步創建的 VM ID debian-11-amd64.qcow2: 在第一步下載的作業系統鏡像 local: 這是 pve 默認的儲存空間命名，如果你有修改/創建過儲存空間，請按你的設定填寫 qm importdisk 8000 debian-11-amd64.qcow2 local 4. 設定虛擬 Disk 被導入的虛擬 Disk 不包含任何設定，他將會是 unused 狀態，需要設定裝置才可以使用\n8000: 在第二步創建的 VM ID local: 這是 pve 默認的儲存空間命名，如果你有修改/創建過儲存空間，請按你的設定填寫 qm set 8000 --scsihw virtio-scsi-pci --scsi0 local:vm-8000-disk-0 5. 創建 cloud-init 裝置 cloud-init 需要 hardware 傳遞設定，把它綁定在沒有被使用的 ide0 上面\n8000: 在第二步創建的 VM ID local: 這是 pve 默認的儲存空間命名，如果你有修改/創建過儲存空間，請按你的設定填寫 qm set 8000 --ide0 local:cloudinit 6. 設定啓動引導 cloud 鏡像不包含引導，需要手動設定啓動裝置\n8000: 在第二步創建的 VM ID scsi0: 在第四步設定的虛擬 Disk 裝置名稱 qm set 8000 --boot c --bootdisk scsi0 7. 設定串口以正常使用部分控制器（可選） 8000: 在第二步創建的 VM ID qm set 8000 --serial0 socket --vga serial0 8. 設定 cloud-init 設定 cloud-init 以在第一次啓動時正常登入\n8000: 在第二步創建的 VM ID \u0026lt;username\u0026gt;: 登入用的使用者名稱 \u0026lt;password\u0026gt;: 登入用的使用者密碼 --ipconfig0: 0 對應虛擬 netcard 0 (net0)，cloud-init 將會設定 net0 的初始化網絡 如使用 dhcp 可以設定為 ip=dhcp qm set 8000 --ciuser \u0026lt;username\u0026gt; --cipassword \u0026lt;password\u0026gt; --ipconfig0 ip=192.168.1.2/24,gw=192.168.1.1 9. 啓動 VM 進行手動調整 這個部分按個人需求修改，但是我可以給出一些修改建議\nCPU: 可以手動設定一些性能優化參數 SSH: cloud 鏡像默認禁止純密碼登入，如有需要可以設定允許 APT: 手動更新包管理器源，安裝常用工具如 git 等 10. 轉換為 Template 在確定所有東西都已經被修改完畢后，關閉 VM 並把它轉換爲 Template\n8000: 在第二步創建的 VM ID qm template 8000 Template 已經創建完畢，關於 Clone 和自動化程式碼的内容將會在下一節出現。\n","permalink":"https://arsfy.top/post/pve-qm-2/","summary":"PVE (Proxmox VE) 提供 VM Template 功能，把一台已經創建好的 VM 轉換為 Template，這在需求大量相同 VM 的場景非常有用。 本節將會展示如何製作 VM Template，並","title":"PVE qm 命令 #2: 製作 VM Template"},{"content":"PVE (Proxmox VE) 提供 qm 命令管理所有 vm，本節將會展示如何使用 qm 命令獲取/變更 vm 的狀態。\n獲取 VM 的狀態 qm status \u0026lt;vmid\u0026gt; VM 一共存在五種不同的狀態:\nRunning (運行中): status: running Stopped (停止): status: stopped Suspended (挂起): status: suspended Unknown (未知): status: unknown Not exist (不存在) Configuration file \u0026#39;nodes/\u0026lt;host\u0026gt;/qemu-server/\u0026lt;vmid\u0026gt;.conf\u0026#39; does not exist Golang 實例程式碼:\nfunc GetVmStatus(id string) string { cmd := exec.Command(\u0026#34;qm\u0026#34;, \u0026#34;status\u0026#34;, id) output, err := cmd.Output() if err != nil { log.Printf(\u0026#34;Failed to get VM status: %v\u0026#34;, err) } if !strings.Contains(string(output), \u0026#34;does not exist\u0026#34;) { return strings.TrimSpace(strings.Replace(string(output), \u0026#34;status: \u0026#34;, \u0026#34;\u0026#34;, -1)) } else { return \u0026#34;not_exist\u0026#34; } } 變更 VM 的狀態 在執行部分動作時，作業系統可能不會回應你的請求，必要時請使用强制動作\nqm xxx \u0026lt;vmid\u0026gt; Start (啓動) qm start \u0026lt;vmid\u0026gt; Shutdown (關機) 這個動作可以選擇包含强制執行參數 --forceStop 1，作業系統可能不會回應這個動作\nqm shutdown \u0026lt;vmid\u0026gt; Stop (停止) 這個動作可以選擇包含强制執行參數 --forceStop 1\nqm stop \u0026lt;vmid\u0026gt; Reboot (重新啓動) qm reboot \u0026lt;vmid\u0026gt; Suspent (挂起) 保留當前 VM 狀態，並暫停 VM\nqm suspent \u0026lt;vmid\u0026gt; Resume (恢復) 恢復被挂起的 VM\nqm resume \u0026lt;vmid\u0026gt; Reset (重設) 强制重新啓動 VM，在 VM Clone -\u0026gt; Reset disk 后首次啓動引起的内核錯誤可以自動化執行這個動作解決\nqm reset \u0026lt;vmid\u0026gt; Destroy (刪除) 刪除指定 VM 和指定 VM 相關的所有 Hardware (完整刪除)\nqm destroy \u0026lt;vmid\u0026gt; ","permalink":"https://arsfy.top/post/pve-qm-1/","summary":"PVE (Proxmox VE) 提供 qm 命令管理所有 vm，本節將會展示如何使用 qm 命令獲取/變更 vm 的狀態。 獲取 VM 的狀態 qm status \u0026lt;vmid\u0026gt; VM 一共存在五種不同的狀態: Running (運行中): status: running Stopped","title":"PVE qm 命令 #1: 獲取/变更 VM 狀態"}]